<?php
/**
 * MUFiles.
 *
 * @copyright Michael Ueberschaer (MU)
 * @license 
 * @package MUFiles
 * @author Michael Ueberschaer <kontakt@webdesign-in-bremen.com>.
 * @link http://webdesign-in-bremen.com
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.6.0 (http://modulestudio.de) at Tue Aug 06 08:44:10 CEST 2013.
 */

/**
 * Upload handler implementation class.
 */
class MUFiles_UploadHandler extends MUFiles_Base_UploadHandler
{
    /**
     * Constructor initialising the supported object types.
     */
    public function __construct()
    {
        $this->allowedObjectTypes = array('file');
        $this->imageFileTypes = array('gif', 'jpeg', 'jpg', 'png', 'swf');
        $this->forbiddenFileTypes = array('cgi', 'pl', 'asp', 'phtml', 'php', 'php3', 'php4', 'php5', 'exe', 'com', 'bat', 'jsp', 'cfm', 'shtml');
        $this->allowedFileSizes = array('file' => array('uploadFile' => ModUtil::getVar('MUFiles', 'maxSize', 102400)));
    }
    
    /**
     * Process a file upload.
     *
     * @param string $objectType Currently treated entity type.
     * @param string $fileData   Form data array.
     * @param string $fieldName  Name of upload field.
     *
     * @return array Resulting file name and collected meta data.
     */
    public function performFileUpload($objectType, $fileData, $fieldName)
    {
        $dom = ZLanguage::getModuleDomain('MUFiles');
    
        $result = array('fileName' => '',
                        'metaData' => array());
    
        // check whether uploads are allowed for the given object type
        if (!in_array($objectType, $this->allowedObjectTypes)) {
            return $result;
        }
    
        // perform validation
        if (!$this->validateFileUpload($objectType, $fileData[$fieldName], $fieldName)) {
            // skip this upload field
            return $result;
        }
    
        // retrieve the final file name
        $fileName = $fileData[$fieldName]['name'];
        $originalName = $fileName;
        $fileNameParts = explode('.', $fileName);
        $extension = strtolower($fileNameParts[count($fileNameParts) - 1]);
        $extension = str_replace('jpeg', 'jpg', $extension);
        $fileNameParts[count($fileNameParts) - 1] = $extension;
        $fileName = implode('.', $fileNameParts);
    
        $serviceManager = ServiceUtil::getManager();
        $controllerHelper = new MUFiles_Util_Controller($serviceManager);
    
        // retrieve the final file name
        try {
            $basePath = $controllerHelper->getFileBaseFolder($objectType, $fieldName);
        } catch (\Exception $e) {
            return LogUtil::registerError($e->getMessage());
        }
        $fileName = $this->determineFileName($objectType, $fieldName, $basePath, $fileName, $extension);
    
        if (!move_uploaded_file($fileData[$fieldName]['tmp_name'], $basePath . $fileName)) {
            return LogUtil::registerError(__('Error! Could not move your file to the destination folder.', $dom));
        }
    
        // collect data to return
        $result['fileName'] = $fileName;
        $result['metaData'] = $this->readMetaDataForFile($fileName, $basePath . $fileName);
        $result['metaData']['originalName'] = $originalName;
    
        return $result;
    }
    
    /**
     * Determines the allowed file extensions for a given object type.
     *
     * @param string $objectType Currently treated entity type.
     * @param string $fieldName  Name of upload field.
     * @param string $extension  Input file extension.
     *
     * @return array the list of allowed file extensions
     */
    protected function isAllowedFileExtension($objectType, $fieldName, $extension)
    {
        // determine the allowed extensions
        $allowedExtensions = array();
        switch ($objectType) {
            case 'file':
                $allowedExtensions = explode(',', ModUtil::getVar('MUFiles','allowedExtensions'));
                break;
        }
    
        if (count($allowedExtensions) > 0) {
            if (!in_array($extension, $allowedExtensions)) {
                return false;
            }
        }
    
        if (in_array($extension, $this->forbiddenFileTypes)) {
            return false;
        }
    
        return true;
    }
}
